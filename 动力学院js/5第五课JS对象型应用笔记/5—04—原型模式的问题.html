<pre>
<script language="javascript">
/****************************
 * 作者：赵呈洋       		*
 * 版权：动力学院     		*
 * 用途：教学讲义与笔记     *
 * 内容：JS对象用法         *
 ****************************
 */
/*
知识点一：原型模式的问题
	原型模式解决了函数共享的问题，但是也省略了给函数传递初始化参数，所有实例都获取了相同的属性值。
	普通属性不是大问题，引用型属性是最大的问题，这是因为原型模式共享的特性导致的。
	请看下面例子： 
*/
	function P(){
	}
	P.prototype.name = "张三";
	P.prototype.like = ["打球","游泳"];
	P.prototype.Say = function(){
		echo(this.name+"说：原型中也能说话！");	
	};
	
	var p1 = new P();
	p1.like.push("学习");
	echo(p1.like);			//输出：打球,游泳,学习 ，没有问题
	
	var p2 = new P();
	p2.like.push("唱歌");
	echo(p2.like);			//输出：打球,游泳,学习,唱歌
	//p2只喜欢 "球,游泳,唱歌" 但是确吧p1的爱好强加给了 p2这是不合理的。
			
 /*
 说明：为了解决这个问题在实际项目中经常把构造函数模式与原型模式的结合一块使用。
 		把可以共享的方法和属性教给原型模式，每个个体特有的属性让构造函数来处理。
		这样就实现每个示例都有自己的一份实例属性副本，同时又共享着对方法的引用，最大限度的节约内存。
 下一节：构造函数模式与原型模式的结合 
 */
	
 













//封装写函数
function echo(  str, flag ){
 	if(arguments[1]==1){
		document.write(arguments[0]);
	}
	else{
		document.writeln(arguments[0]);
	}
	
} 
</script>
</pre>
