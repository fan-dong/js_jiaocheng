<pre>
<script language="javascript">
/****************************
 * 作者：赵呈洋       		*
 * 版权：动力学院     		*
 * 用途：教学讲义与笔记     *
 * 内容：函数应用           *
 ****************************
 */
/*
知识点一：基本类型与引用类型的理解
	在编程语言中常用有基本类型和引用类型，基本类型主要是字符串，数值，布尔这样小数据。
	引用类型指：对象，数组，函数等大数据体。
基本类型和引用类型的区别：
	a=3;
	b=a; 
	这个时候b指向的值也是3。 但是b里面的3和a里面的3是完全独立的。	
	在用等号给赋值基本类型的时候，会产生一个值的复制副本。赋值完成后
	a和b相互独立。
	
	//引用类型
	a = [1,2,3]
	b = a 这个时候a也产生一个复制副本，这次复制的不是具体值，而是复制了一份指针副本给b
	让b也指向了相同的数组。	修改b会影响a的结果,修改a同样会影响b的结果。但这并不是永恒的。
	代码示例如下：
*/
	var a = [1,2,3];
	var b = a;
	b[3] = "PHP";
	echo(a); //输出：1,2,3,PHP 

//代码示例二
	var a = [1,2,3];
	var b = a;
	a = 555
	echo(b); //输出：1,2,3 . b并没有跟着a去变化。

/*
说明：引用是指绑定对象不变的情况下会同步变化，当绑定对象发生变化了，就不再同步。
可以这样理解：数组[1,2,3]本身是个对象，a和b是两个变量，当用等号把数组赋值给a的时候,
实际上是把数组在内存中的地址给a。这样a就能找到数组。当用b=a的时候，a又把数组给他的内存地址复制一个副本
给b。这样 a和b都和数组对象[1,2,3]产生了绑定。对a或b上面应用数组操作时候,会直接去操作他们背后的实际对象。
所以他们结果同步。
但是当我们另赋基本类型555给a的时候，a会直接保存555的地址。不再保存原来数组对象的地址。
但是b中保存的内存地址没有变化。
*/


	var fnA1 = function(){ echo("fnA1");}
	var fnA2 = fnA1;
	fnA1 = 5;
	fnA2();


	

/*
知识点二：变量的作用域一，看下面的例子来理解作用域
*/ 
var a=20;
function fnA(){
	echo(a);		//输出20 函数体外面定义的里面可以访问
	var b=30;		//这种只能在函数内部访问的叫局部变量
	c=40;			//这种可以再所有地方访问的叫全局变量
}
fnA(); //输出20
echo(typeof b);  //undefined
echo(typeof c);	  //number
/*
说明：在函数外定义的无论是否使用var关键字，变量都具有全局作用域，就是函数内核函数外都可以直接使用。
函数内的如果是通过var定的变量只能在函数内中访问，在函数外无法访问。没有通过var定义的变量默认是全局变量。
变量作用域学习测试方法：可以通过返回值进行判断测试。
*/

//看下面的例子
echo('-------------函数中的函数变量作用域情况-------');
function fnA1(){
	var a1 = "A1中的局部变量";
	a12 = "A1中的全局变量";
	function fnB1(){
		var b1 = "b1中的局部变量";
		b2 = "b1中的全局变量";
	   echo(typeof a1)	;		//string 外层函数中的局部变量内层函数可以访问
	   echo(typeof a12);		//string
	}
	fnB1();
	echo(typeof b1)	;			//undefined 内层函数中的局部变量外层函数无法访问
	echo(typeof b2);			//string 内层函数中的局部变量外层函数无法访问
}
fnA1();
echo(b2);	//b1中的全局变量,在这里也可以访问


//知识点三：函数与函数内变量的声明提权，看下面的例子
i = 1; 
alert(x); 
var fnA = function() { 
alert(i); 
var i = 2; 
alert(i); 
} 
fnA();  //输出：1，undefined，2 为什么没有输出，1,1,2呢？
/*
说明：因为js编译器在执行这个fnA函数的时候，会把函数体里面的声明的变量的行为提到最前面进行。
其实上面的代码等同于下面的这段代码： 
i = 1; 
alert(i); 
var y = function() {
	var i;			//此时i还未赋值，所以为undefined。 
	alert(i); 
	i = 2; 			//把函数内部声明提前
	alert(i); 
} 
fnA(); 
如果把var i = 2;这段代码给删掉，在内部它没有进行var声明。它会一直沿着作用域向上找，此时的i就为全局i. 
*/



/*
知识点四：深刻理解变量名的含义
请问下面代码执行结果是什么？
var a = 5;
function a(b){
	alert(b);
}
a(6);
alert(a); 
*/


/*作业题目：
题目一：
var a =5;
function b(){
	 a = 10;
}
b();
alert(a);  //请问输出什么？为什么？

题目二：
var a =5;
function b(){
	 a = 10;
	 return;
	 function a(){}
}
b();
alert(a);  //请问输出什么？为什么？
*/



//封装写函数
function echo(  str, flag ){
 	if(arguments[1]==1){
		document.write(arguments[0]);
	}
	else{
		document.writeln(arguments[0]);
	}
	
} 
</script>
</pre>